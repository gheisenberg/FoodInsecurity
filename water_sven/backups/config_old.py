import os
from tensorflow.keras import losses
from tensorflow.keras import metrics
########################################################################################################################
#                                   Performance Settings, Multi-GPU-usage
########################################################################################################################
# list of gpus to use
# (only use 1 GPU!) Otherwise I will kill your process!
# We all need to calculate on this machine - might get lowered to one, if there are bottlenecks!
gpus = [0]

########################################################################################################################
#                                           Verbosity settings
########################################################################################################################
#handles verbosity of thzooe program (use 1 or above to get feedback!)
verbose = False
# 'debug' for debugging, 'info' for a bit verbosity, 'warning' for less verbosity
logging = 'info'

########################################################################################################################
#                                           Base Folder
########################################################################################################################
### The folder where the project path and data is located, subfolder paths will be automatically generated
#Note: Pathes need to have the structure of /path/to/file and a folder need to end with an '/'
base_folder = '/mnt/datadisk/data/'
# The folder where your project files are located
prj_folder = '/mnt/datadisk/data/Projects/water/'
# train history will be saved in a subfolder of the project path (base_folder + /projects/water/)
# assign a name according to your group, to separate your results from all others! Create this folder manually!
trainHistory_subname = 'trainH_XV2/'
labels_f = prj_folder + '/inputs/water_labels_strat_split.csv'
# img_path = '/mnt/datadisk/data/Sentinel2/preprocessed/water_new/'
# img_path = ['/mnt/datadisk2/preprocessed/R/996x996_c432_fillmean_m2.5_rlocal channel mean_clipvoutlier_normZ_f18977/',]
img_path = ['/mnt/datadisk2/preprocessed/all/996x996_c432_fillmean_m2.5_rlocal channel mean_clipvoutlier_normZ_f31213/']
#use directory with multiple folders
load_subfolders = False
tmp_p = '/mnt/datadisk2/tmp/'
########################################################################################################################
#                                            Run Name
########################################################################################################################
### The name of the model run gets generated by mutiple Settings (e.g. model_name, normalization and augmentation
# settings and many more, it will be created as a folder where all results model checkpoints, evaluation charts etc. pp
# are saved
# run_name_custom_string is a custom string you can provide to add to the run name
run_name_custom_string = ''


########################################################################################################################
#                                       Dataset parameters
########################################################################################################################
# 3 Main label categories - everything else is thrown away
# label_name = ['source of drinking water (weights): max']
# label_name = ['source of drinking water (simplified): max', 'source of drinking water (categorized by type): max',
# label_name = ['source of drinking water (categorized): max', 'source of drinking water (weights): max',
#               'location of source for water (refurbished): max']
# label_name = {'time to get to water source (minutes)': {'max value': 31, 'drop max value': True},
# label_name = {'time to get to water source (refurbished)': {'max value': 31, 'drop max value': True},
#               # 'time to get to water source + penalty': {'max value': 41, 'drop max value': True},
#               'time to get to water source (refurbished) + penalty': {'max value': 41, 'drop max value': True}}
label_name = {
    # 'PCA w_location_weighting urban0': {},
    # 'PCA w_location_weighting all0': {'max value': 2.5, 'drop min max value': True,
    #                            'min value': -2.5},
    # 'PCA w_location_weighting all1': {},
    'PCA w_location_weighting all2': {'label normalization': 'Z',}
                                    # 'max value': 3, 'drop min max value': True,
                                    # 'min value': -3},
    # 'PCA w_weighting urban3': {'max std': 2.5, 'drop min max value': False,
    #                            'min std': -2.5},
    # 'time to get to water source (refurbished)0': {'max value': 31, 'min value': 0,
    #                                               'drop min max value': True,
    #                                               'label normalization': 'Z'}, #bad
    # 'time to get to water source (refurbished)1': {'max value': 31, 'min value': 0,
    #                                               'drop min max value': False,
    #                                               'label normalization': 'Z'}, #best1
    # # 'time to get to water source (refurbished)2': {'max value': 31, 'min value': 0,
    # #                                               'drop min max value': True}, #bad
    # 'time to get to water source (refurbished)5': {'max value': 31, 'min value': 0,
    #                                               'drop min max value': False}, #ok
    # 'time to get to water source (refurbished)6': {'max value': 31, 'min value': 0,
    #                                                 'label normalization': '0,1',
    #                                                'drop min max value': False}, #ok
    # 'time to get to water source (refurbished)7': {'max value': 31, 'min value': 0,
    #                                                 'label normalization': '0,1',
    #                                                'label transform': 'boxcox',
    #                                                'drop min max value': False},#ok
    # 'time to get to water source (refurbished)8': {'label normalization': '0,1',
    #                                                'label transform': 'boxcox'},
    # 'time to get to water source (refurbished)4': {'label normalization': 'Z',
    #                                                'label transform': 'boxcox'},
    # 'time to get to water source (refurbished)3': {'max value': 31, 'min value': 0,
    #                                                'drop min max value': False,
    #                                                'label normalization': 'Z',
    #                                                'label transform': 'boxcox'},#best2
    # 'time to get to water source (refurbished)4': {'max value': 31, 'min value': 0,
    #                                               'drop min max value': True,
    #                                               'label normalization': 'Z',
    #                                               'label transform': 'boxcox'},
#     'time to get to water source (refurbished) + penalty0': {'max value': 41, 'min value': 0,
#                                                   'drop min max value': True,
#                                                   'label normalization': 'Z'},
#     'time to get to water source (refurbished) + penalty1': {'max value': 41, 'min value': 0,
#                                                   'drop min max value': False,
#                                                   'label normalization': 'Z'},
#     'time to get to water source (refurbished) + penalty2': {'max value': 41, 'min value': 0,
#                                                   'drop min max value': True},
#     'time to get to water source (refurbished) + penalty5': {'max value': 41, 'min value': 0,
#                                                   'drop min max value': False},
#     'time to get to water source (refurbished) + penalty3': {'max value': 41, 'min value': 0,
#                                                   'drop min max value': False,
#                                                   'label normalization': 'Z',
#                                                   'label transform': 'boxcox'},
#     'time to get to water source (refurbished) + penalty4': {'max value': 41, 'min value': 0,
#                                                   'drop min max value': True,
#                                                   'label normalization': 'Z',
#                                                   'label transform': 'boxcox'},
}
              # 'time to get to water source + penalty': {'max value': 41, 'drop max value': True},
              # 'time to get to water source (refurbished) + penalty': {'max value': 41, 'drop max value': True}}
# label_name = {'source of drinking water (categorized urban): max1': {}}
#removes all label data before 2012
label_min_year = 2012

# Channels use False for preprocessed images (define channels which should be used, if you want to use a subset of these channels)
channels = False
#height and width of input images (in Pixels), False defaults to max input size of preprocessed images
dim_l = [False]#[50, 100, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 900, False]

########################################################################################################################
#                                  Basic neural network parameters
########################################################################################################################
### Maximum amount of epochs
epochs = 100
### Learning rate (to start with - might get dynamically lowered with callback options)
lr = 0.0001
# How many pictures are used to train before readjusting weights
batch_size = 32
### The model to use
# available are vgg16/19, resnet50/152, inceptionv3, xception, densnet121/201
model_name = 'vgg19'
# loss function
#keras losses and metrics imports - do not initialize!!! Need to be called in strategy scope
#CategoricalCrossentropy or MeanSquaredError
loss = losses.MeanSquaredError
#CategoricalAccuracy or RootMeanSquaredError
metrics_l = [metrics.RootMeanSquaredError]
#categorical or regression
type_m = 'regression'
#use an int to limit data on that amount or False to use full dataset (and not testing mode)
test_mode = 1000
#Z, 0,1 #gets overwritten if passed to label_name dict
label_normalization = False
#boxcox #gets overwritten if passed to label_name dict
label_transform = False
#split defines the split mode used (refer to labels.csv). Usually used to differentiate by predicting random data, data
#from another country ('out of country') or from another survey/time or another country ('country year')
splits_l = [
    # 'split: out of country all (w TIF)',
    # 'split: out of country all (w TIF) excluded outlier surveys',
    # 'split: out of adm1 all (w TIF)',
    # 'split: out of adm2 all (w TIF) random',
    'split: out of country year all (w TIF)',
    'split: out of country year all (w TIF) excluded outlier surveys',

    # 'split: out of country urban (w TIF)',
    # 'split: random urban (w TIF)',
    # 'split: out of country all (w TIF) excluded outlier surveys',
    # 'split: out of country year all (w TIF) excluded outlier surveys',
    # 'split: out of adm1 all (w TIF) excluded outlier surveys',
    'split: out of adm1 year all (w TIF)',
    'split: out of adm1 year all (w TIF) excluded outlier surveys',
    'split: out of adm2 year all (w TIF)',
    'split: out of adm2 year all (w TIF) excluded outlier surveys',
    # 'split: out of adm1 year all (w TIF) excluded outlier surveys random',
    # 'split: out of adm2 all (w TIF) random',
    # 'split: out of adm2 all (w TIF) excluded outlier surveys random',
    # 'split: random all (w TIF)', 'split: random all (w TIF) excluded outlier surveys',
    # 'split: random rural (w TIF) excluded outlier surveys',
    # 'split: random urban (w TIF) excluded outlier surveys',
    # 'split: random without <2015 all (w TIF) excluded outlier surveys',
            ]
#only uses the first split for validation (way faster - for hyperparameter optimization and co)
dont_use_crossval = False
# chose your optimizer
optimizer = "SGD"
# momentum influences the lr (high lr when big changes occur and low lr when low changes occur)
momentum = 0.9
report_original_data = False
### The shape of X and Y with ((batch_size, height, width, channels), (batch_size, number of labels))
# # to do:read from file
# input_shape = (batch_size, 200, 200, channel_size)

### CNN settings which are parameters of the tf.keras.applications Model
# 'include_top': Use the same top layers (aka final layers with softmax on output classes) - should always be "False" here
# 'weights': 'imagenet' or False - transfer learning option - will be overwritten if model weights are given in
# load_model_weights. Only takes effect with include_top=False
# classifier activation: A str or callable. The activation function to use on the "top" layer. Ignored unless include_top=True.
# Set classifier_activation=None to return the logits of the "top" layer.
# When loading pretrained weights, classifier_activation can only be None or "softmax".
# others kinda explain themselves
# cnn_settings_d = {'include_top': False, 'weights': 'imagenet', 'input_tensor': None,
#                    'input_shape': (input_shape[3], input_shape[1], input_shape[2]), 'pooling': False}
#                   #'classifier_activation': 'softmax'}
cnn_settings_d = {'include_top': False, 'weights': 'imagenet', 'input_tensor': None, 'pooling': False}
                  #'classifier_activation': 'softmax'}
# Use dropout on top layers - use 0 to 1
dropout_top_layers = 0
# Make weights trainable. Unfreezes layers beginning at top layers. Use 0 to 100 (percent)
unfreeze_layers_perc = 100
### Use custom top layers (necessary when using transferlearning)
# 2 layers right now. Their neurons can be adjusted
add_custom_top_layers = True
# define how many hidden layers shall be added as top layers (len(neurons_l)) and how many neurons they should have (int)
neurons_l = [1024, 512]



########################################################################################################################
#                                       Callback options
########################################################################################################################
# automatically decrease lr (first value True) if there was no decrease in loss after x epochs (2nd value)
# 3rd multiplicator for lr
auto_adjust_lr = (False, 1, 0.8)
# model stops (first value True) when loss doesnt decrease over epochs (2nd value)
early_stopping = (True, 8)


########################################################################################################################
#                       Image Augmentation settings
########################################################################################################################
### Image Augmentation settings
# all possible values below
# accuracy decreases with to many Augmentation settings, though - why?
# dict of dicts to be able to test multiple settings in a testing strategy
# augmentation only gets applied to train data
IDG_augmentation_settings_d = {
    'noset12': {},
    # 'subset13': {
    #     #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
    #     # 'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
    #     'zoom_range': 0.2,
    #     #'channel_shift_range': 0.3,
    #     'horizontal_flip': True,
    #     #'vertical_flip': True,
    #     'rotation_range': 0.20, #a float represented as fraction of 2 Pi
    #     # 'width_shift_range': 0.2,
    #     # 'height_shift_range': 0.2
    # },
    # 'subset11': {
    #     # 'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
    #     # 'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
    #     # 'zoom_range': 0.2,
    #     # 'channel_shift_range': 0.3,
    #     'horizontal_flip': True,
    #     # 'vertical_flip': True,
    #     # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
    #     # 'width_shift_range': 0.2,
    #     # 'height_shift_range': 0.2
    # },
    # # 'noset12': {},
    # 'subset1': {
    #     #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
    #     #'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
    #     #'zoom_range': 0.2,
    #     #'channel_shift_range': 0.3,
    #     'horizontal_flip': True,
    #     'vertical_flip': True,
    #     # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
    #     #'width_shift_range': 0.2,
    #     #'height_shift_range': 0.2
    #     },
    # 'subset111': {
    #     # 'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
    #     # 'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
    #     # 'zoom_range': 0.2,
    #     # 'channel_shift_range': 0.3,
    #     # 'horizontal_flip': True,
    #     'vertical_flip': True,
    #     # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
    #     # 'width_shift_range': 0.2,
    #     # 'height_shift_range': 0.2
    # },
    # 'subset2': {
    #     # 'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
    #     # 'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
    #     # 'zoom_range': 0.2,
    #     # 'channel_shift_range': 0.3,
    #     'horizontal_flip': True,
    #     'vertical_flip': True,
    #     # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
    #     # 'width_shift_range': 0.2,
    #     # 'height_shift_range': 0.2
    # },
# 'subset9': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         # 'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         'zoom_range': 0.2,
#         # 'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         #'vertical_flip': True,
#         'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         # 'width_shift_range': 0.2,
#         # 'height_shift_range': 0.2
#     },
# 'subset10': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         # 'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         'zoom_range': 0.2,
#         # 'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         'vertical_flip': True,
#         'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         # 'width_shift_range': 0.2,
#         # 'height_shift_range': 0.2
#     },
    # 'subset11': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         #'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         'zoom_range': 0.2,
#         'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         #'vertical_flip': True,
#         # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         # 'width_shift_range': 0.2,
#         # 'height_shift_range': 0.2
#     },
# 'subset12': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         #'zoom_range': 0.2,
#         'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         #'vertical_flip': True,
#         # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         # 'width_shift_range': 0.2,
#         # 'height_shift_range': 0.2
#     },
# 'subset14': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         #'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         'zoom_range': 0.2,
#         #'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         #'vertical_flip': True,
#         # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         # 'width_shift_range': 0.2,
#         # 'height_shift_range': 0.2
#     },
# 'subset15': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         #'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         #'zoom_range': 0.2,
#         'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         #'vertical_flip': True,
#         # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         # 'width_shift_range': 0.2,
#         # 'height_shift_range': 0.2
#     },
}
# #
# IDG_augmentation_settings_d = {'subset1': {
#         #'brightness_range': [0.9, 1.1], #Tuple or list of two floats. Range for picking a brightness shift value from.
#         #'shear_range': 0.2, #Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)
#         #'zoom_range': 0.2,
#         #'channel_shift_range': 0.3,
#         'horizontal_flip': True,
#         #'vertical_flip': True,
#         # 'rotation_range': 0.20, #a float represented as fraction of 2 Pi
#         #'width_shift_range': 0.2,
#         #'height_shift_range': 0.2
#         }}
########################################################################################################################
#                               Continuing from earlier runs
########################################################################################################################
### False or modelcheckp(oint) folder from which to load weights
load_model_weights = False
# \
#     os.path.join(prj_folder, 'trainHistory_rural', 'PCA_w_location_weighting_rural1',
# '996x996_c432_fillmean_m2.5_rlocal_channel_mean_clipvoutlier_normZ_f18977vgg19_wimagenet_unfl100_d0_lr0.0001_momentum0.9_optimizerSGD__m_vgg19_17',
#                  'modelcheckp', '')


########################################################################################################################
#                               Evaluation Settings & Images
########################################################################################################################
### You can reload the best model epoch (True/False) - in that case evaluation is done on both, the best model epoch and
# the last one
# overrides other weights imports (e.g. imagenet in Keras models)
reload_best_weights_for_eval = True
### You can show and/or save your augmented images to become an idea of what actually goes into the model
# False or Number of images (for train, val and test gen)
save_augmented_images = 5
tensorboard = True
